## iomanager

在高性能服务器框架中，IO管理是非常重要的一环。由于高性能服务器需要处理大量的IO请求，因此有效地管理和处理这些IO操作可以显著提升系统的性能。

在IO管理方面，高性能服务器框架通常会采取以下几种策略：

1. **异步IO**：使用异步IO可以将IO操作与后续的处理逻辑解耦，从而提高系统的并发性能。服务器框架可以使用操作系统提供的异步IO接口，如epoll或IOCP，来实现高效的异步IO处理。
2. **事件驱动模型**：高性能服务器框架通常会使用事件驱动的模型来处理IO事件。通过注册IO事件的回调函数，并使用事件循环机制来监听和处理这些事件，可以有效地管理系统的IO操作。
3. **线程池**：在高性能服务器框架中，使用线程池来处理IO操作是常见的优化策略。通过将IO操作分发给多个线程并行处理，可以充分利用多核资源，提高系统的处理能力。
4. **内存池管理**：高性能服务器框架通常会使用内存池来管理内存的申请和释放。通过预先分配一块连续的内存空间，并按需从内存池中获取和释放内存，可以减少内存碎片和频繁的内存申请操作，提高系统的效率。
5. **缓存和批处理**：通过使用缓存和批处理技术，可以将多个IO请求合并为更少的IO操作，从而减少系统的IO开销。例如，可以将多个小的网络请求合并为一个大的网络请求，或者将多个小的磁盘读写请求合并为一个大的磁盘操作。

通过以上这些策略，高性能服务器框架可以有效地管理和处理大量的IO操作，提升系统的性能和并发能力。同时，IO管理也是服务器框架中需要重点优化和调优的部分，不同的应用场景可能需要针对性地选择和实现不同的IO管理策略。



一个基于Epoll的IO协程调度器的实现。它继承了Scheduler和TimerManager两个类。

**成员函数：**

- addEvent()函数：用于向IOManager中添加一个事件，包括指定的socket句柄、事件类型和事件回调函数。它首先根据文件描述符获取事件上下文，然后进行一系列的操作，包括设置`epoll_ctl`的操作类型、设置监听的事件类型、更新事件上下文等。最后返回0表示添加事件成功。

- delEvent()函数：用于从IOManager中删除指定的事件，但不触发该事件。

- cancelEvent()函数：用于取消指定的事件，如果事件存在，则触发该事件。

  **取消和删除的区别就在于，前者会触发一个新事件重新调度，删除会将事件上下文reset置空**

- cancelAll()函数：用于取消指定socket句柄上的所有事件。

- tickle()函数：用于向IOManager发送一个信号，以唤醒等待中的IO操作。

- stopping()函数：判断当前IOManager是否需要停止。

- idle()函数：当没有IO事件要处理时，调用该函数进行空闲处理。

- onTimerInsertedAtFront()函数：当有定时器插入到队列头时，调用该函数进行处理。

- contextResize()函数：重置socket句柄上下文的容器大小。

- stopping()函数：判断是否可以停止IOManager，并返回最近要触发的定时器事件间隔。

**构造函数：**

1. 使用传入的线程数、是否使用调用线程作为协程调度器以及名称等参数，调用`Scheduler`的构造函数进行初始化。
2. **调用`epoll_create`函数创建一个`epoll`实例，并将返回的文件描述符赋值给成员变量`m_epfd`。然后对`m_epfd`进行断言检查，确保文件描述符创建成功。**
3. **调用`pipe`函数创建一个管道**，将对应的文件描述符保存在`m_tickleFds`数组中。然后对`pipe`函数的返回值进行断言检查，确保管道创建成功。
4. **创建一个`epoll_event`结构体对象`event`，并将其进行初始化**，包括将`event`的事件类型设置为`EPOLLIN | EPOLLET`，表示可读事件和边缘触发事件，将`event.data.fd`设置为`m_tickleFds[0]`，**表示事件关联的文件描述符是管道的读端**。
5. **调用`fcntl`函数将`m_tickleFds[0]`设置为非阻塞模式**，利用`O_NONBLOCK`标志进行设置。然后对`fcntl`函数的返回值进行断言检查，确保设置成功。
6. **调用`epoll_ctl`函数将`m_tickleFds[0]`添加到`m_epfd`的事件监听中**，并将对应的事件设置为`event`。然后对`epoll_ctl`函数的返回值进行断言检查，确保添加成功。
7. 调用`contextResize`方法，将`m_fdContexts`向量的大小设置为32。
8. 调用`start`方法，启动IO线程。



**成员变量：**

1. `m_epfd`：`int`类型的变量，表示`epoll`文件句柄。用于创建和操作`epoll`实例。
2. `m_tickleFds`：包含两个`int`类型的变量的数组，表示`pipe`文件句柄。用于唤醒等待中的IO操作。
3. `m_pendingEventCount`：`std::atomic<size_t>`类型的变量，表示当前等待执行的事件数量。是一个原子变量，用于保证线程安全的操作。
4. `m_mutex`：`RWMutexType`类型的变量，表示IOManager的互斥锁。用于保护共享数据的访问。
5. `m_fdContexts`：`std::vector<FdContext*>`类型的变量，表示socket事件上下文的容器。存储每个socket句柄的事件上下文信息。

其中，`FdContext`是一个内部类，它定义了以下成员变量：

1. `read`：表示读事件的上下文，包含调度器指针、协程指针和回调函数等。
2. `write`：表示写事件的上下文，也包含调度器指针、协程指针和回调函数等。
3. `fd`：表示事件关联的句柄。
4. `events`：表示当前的事件类型。
5. `mutex`：`MutexType`类型的变量，表示事件的互斥锁。用于保护事件上下文的访问。

内部类FdContext，用于存储每个socket句柄的事件上下文信息。该类中包含了读事件和写事件的上下文，以及相关的协程调度器、协程和回调函数等。

整体来说，实现了一个基于Epoll的IO协程调度器，可以高效地管理和处理大量的IO事件。它支持添加、删除、取消和处理不同类型的IO事件，并且可以与协程配合使用，提供高性能的IO管理能力。